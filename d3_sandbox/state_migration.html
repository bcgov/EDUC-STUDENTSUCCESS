<!DOCTYPE html>
<meta charset="utf-8">
<html>

<head>
	<title>State migration</title>
	<link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css">
	<style type="text/css">
		#tt {
			pointer-events: none;
			color: white;
		}

		#tipContainer {
			font-size: 16px;
			position: absolute;
			width: 180px;
			z-index: 100;
			background-repeat: no-repeat;
			text-align: left;
			line-height: 20px;
		}

		#tipLocation {
			font-weight: normal;
			font-family: Georgia;
			font-style: Italic;
			color: white;
			margin: 0px;
			padding: 10px 10px;
			background: #333;
			font-size: 14px;
		}

		#tipCount {
			font-weight: bold;
			font-size: 32px;
			letter-spacing: -1px;
			margin: 0px;
			padding: 0px 10px 10px 10px;
			color: #333;
		}

		#tipKey {
			font-weight: normal;
			font-size: 10px;
			color: #333;
			margin: 0px;
			padding: 5px 0px 5px 10px;
			background: rgba(218, 218, 218, 0.5);
		}

		#tt2 {
			pointer-events: none;
			color: white;
		}

		#tipContainer2 {
			font-size: 16px;
			position: absolute;
			width: 250px;
			z-index: 100;
			background-repeat: no-repeat;
			text-align: left;
			line-height: 20px;
		}

		#tipLocation2 {
			font-weight: normal;
			font-family: Georgia;
			font-style: Italic;
			color: white;
			margin: 0px;
			padding: 10px 10px;
			background: #333;
			font-size: 14px;
		}

		#tipCount2 {
			font-weight: bold;
			font-size: 32px;
			letter-spacing: -1px;
			margin: 0px;
			padding: 0px 10px 10px 10px;
			color: #333;
		}

		#tipKey2 {
			font-weight: normal;
			font-size: 10px;
			color: #333;
			margin: 0px;
			padding: 5px 0px 5px 10px;
			background: rgba(218, 218, 218, 0.5);
		}

		.tipClear {
			clear: both;
		}
	</style>



</head>

<body class="pl-4 pt-4">



	<h4>Immigration and Emigration</h4>
	<p>Circles are sized by net migration to and from the corresponding state - green indicates positive net migration
		(more people are moving to the state than from it), red indicates negative net migration (more people are moving away
		from the state than to it). Hover over a state for raw numbers. Click a state to view migration flows to and from
		that state - again, green indicates net gain for the selected state, red indicates net loss.</p>

	<div id="maincontainer" style="position:absolute;">



		<div id="map"></div>




	</div>












	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>



	<script type="text/javascript">
		//Width and height
		var width = 950;
		var height = 600;
		var centered;

		var formatC = d3.format(",.0f");
		var formatD = d3.format("+,.0f");

		//var of min & max number of people move in and out 
		var immin, immax, exmin, exmax;


		//create the projection expression
		var projection = d3.geoAlbersUsa()
			.scale(1000)
			.translate([width / 2, height / 2]);

		//Define path generator
		var path = d3.geoPath()
			.projection(projection);

		var colors = ["#EDF8FB", "#41083e"]; //color range based on the number of people
		var immdomain = [24431, 537148]; //domain of min-max 
		var emmdomain = [20056, 566986];


		//create scales
		var circleSize = d3.scaleLinear().range([0, 25000]).domain([0, 137175]);

		var lineSize = d3.scaleLinear().range([2, 25]).domain([0, 35000]);

		var fillcolor = d3.scaleLinear().range(colors).domain(immdomain);


		//Create SVG element
		var svg = d3.select("#map")
			.append("svg")
			.attr("width", width)
			.attr("height", height);


		var fp = d3.format(".1f"); // format number, 1 place after decimal

		//initialize html tooltip
		var tooltip = d3.select("#maincontainer")
			.append("div")
			.attr("id", "tt")
			.style("z-index", "10")
			.style("position", "absolute")
			.style("visibility", "hidden");

		var tooltip2 = d3.select("#maincontainer")
			.append("div")
			.attr("id", "tt2")
			.style("z-index", "10")
			.style("position", "absolute")
			.style("visibility", "hidden");

		var chartGroup = svg.append("g");




		var comingData, goingData;
		d3.csv("coming.csv", function (data) {
			comingData = data;

		});

		d3.csv("going.csv", function (data) {
			goingData = data;

			d3.json("states.json", function (json) {

				//loop through the csv, length is the total number of rows(states)
				for (var i = 0; i < data.length; i++) {
					var dataState = data[i].state; //state names in csv data
					var tempObj = {};//crate a temp object

					//for...in statement iterates over all non-Symbol, enumerable properties (columns) of an object(each row)
					for (var propt in data[i]) {
						var valz = parseFloat(data[i][propt]); //parseFloat() parses a string and returns a floating point number
						tempObj[propt] = valz;
					}

					//Find the corresponding state inside the GeoJSON
					for (var j = 0; j < json.features.length; j++) {

						var jsonState = json.features[j].properties.name; //state names in json file

						if (dataState == jsonState) {

							matched = true; //match flag
							//create new properties and add vals in json
							json.features[j].properties.state = dataState;
							json.features[j].id = dataState;
							json.features[j].abbrev = data[i].abbrev;
							json.features[j].ind = i;

							//loop all propt in this temp object
							for (var propt in tempObj) {
								//check if it's a number
								if (!isNaN(tempObj[propt])) {
									//add properties&vals to json
									json.features[j].properties[propt] = tempObj[propt];
								}

							}
							break;
						}
					}
				}


				//Bind data and create one path per GeoJSON feature
				chartGroup.selectAll("path")
					.data(json.features)
					.enter()
					.append("path")
					.attr("class", "state")
					//attach district name to each path (district shape on map)
					.attr("id", function (d) {
						return d.properties.state;
					})
					.attr("d", path)
					.attr("stroke-width", 0.5)
					.style("stroke", "#666")
					.style("fill", "#fff");

				//Bind data to circles per GeoJSON feature/state	
				chartGroup.selectAll("circle")
					.data(json.features)
					.enter().append("circle")
					.attr("cx", function (d) {
						var centname = d.properties.name;
						var ctroid;
						ctroid = path.centroid(d)[0]; // get the centroid x
						return ctroid;
					})
					.attr("cy", function (d) {
						var centname = d.properties.name;
						var ctroid;
						ctroid = path.centroid(d)[1];  // get the centroid y
						return ctroid;
					})
					.attr("r", function (d) {
						//radius of the circle is defined by the number of total net migration change

						/*total_imm and totale_emm are columbs from csv file
						got added to json features through :    
						json.features[j].properties[propt] = tempObj[propt];*/
						var diff = d.properties.total_imm - d.properties.total_emm;
						return circleSize(Math.sqrt(Math.abs(diff) / Math.PI));

					})
					.attr("class", "circ")
					//attach district name to each circle
					.attr("id", function (d) { return d.abbrev; })
					.attr("fill", function (d) {
						/*fill the color based on -/+ net changes*/
						var diff = d.properties.total_imm - d.properties.total_emm;
						if (diff > 0) {
							return "#65a89d";
						} else {
							return "#a96a46";
						}

					})
					.attr("fill-opacity", "0.5")
					.attr("stroke", "#fff")
					.attr("stroke-weight", "0.5")

					// add event listener for mouse over
					.on("mouseenter", function (d) {
						//toolOver is the event handler
						return toolOver(d, this);
					})
					.on("mousemove", function (d) {
						//gets mouse coordinates on screen
						var m = d3.mouse(this);
						mx = m[0];
						my = m[1];

						return toolMove(mx, my, d);
					})
					.on("mouseleave", function (d) {
						return toolOut(d, this);
					})
					.on("click", function (d) { clicked(d) });


			});
		});

		function toolOver(v, thepath) {
			d3.select(thepath)
				//in v4+ use the "long forms"
				.attr("fill-opacity", "0.7")
				.attr("cursor", "pointer");
			return tooltip.style("visibility", "visible");
		};

		function toolOut(m, thepath) {
			d3.select(thepath)
				.attr("fill-opacity", "0.5")
				.attr("cursor", "");
			return tooltip.style("visibility", "hidden");
		};


		function toolMove(mx, my, data) {

			if (mx < 120) {
				mx = 120
			};

			if (my < 40) {
				my = 40
			};

			//create the tooltip, style it and inject info
			return tooltip.style("top", my + -140 + "px")
				.style("left", mx - 120 + "px")
				.html("<div id='tipContainer'><div id='tipLocation'><b>" + data.id +
					"</b></div><div id='tipKey'>Migration in: <b>" + formatC(data.properties.total_imm) +
					"</b><br>Migration out: <b>" + formatC(data.properties.total_emm) +
					"</b><br>Net migration: <b>" + formatC((data.properties.total_imm - data.properties.total_emm)) +
					"</b></div><div class='tipClear'></div> </div>");
		};


		//toolOver2 and ...2 are event handlers for paths btw two districts
		function toolOver2(v, thepath) {

			d3.select(thepath)
				//in v4+ use the "long forms", opacity for stroke, fill-opacity for shape bg
				.attr("opacity", "0.7")
				.attr("cursor", "pointer");
			return tooltip2.style("visibility", "visible");
		};

		function toolOut2(m, thepath) {
			d3.select(thepath)
				//in v4+ use the "long forms"
				.attr("opacity", "0.5")
				.attr("cursor", "");
			return tooltip2.style("visibility", "hidden");
		};

		function toolMove2(mx, my, home, end, v1, v2) {
			var diff = v1 - v2;

			if (mx < 120) {
				mx = 120
			};

			if (my < 40) {
				my = 40
			};

			//create the tooltip for paths, style it and inject info
			return tooltip2.style("top", my + -140 + "px")
				.style("left", mx - 120 + "px")
				.html("<div id='tipContainer2'><div id='tipLocation'><b>" + home +
					"/" + end + "</b></div><div id='tipKey2'>Migration, " + home +
					" to " + end + ": <b>" + formatC(v2) + "</b><br>Migration, " + end +
					" to " + home + ": <b>" + formatC(v1) + "</b><br>Net change, " + home +
					": <b>" + formatD(v1 - v2) + "</b></div><div class='tipClear'></div> </div>");
		};

		//function crates the path
		function clicked(selected) {
			//var coming = selected.properties;
			var selname = selected.id;
			console.log(selname);

			/*
				d3.selectAll(".circ")
				.attr("fill-opacity", "0.2");
			*/

			// path creates that target district map
			var homex = path.centroid(selected)[0];
			var homey = path.centroid(selected)[1];

			chartGroup.selectAll(".goingline")
				//dash css, 0 solid
				.attr("stroke-dasharray", 0)
				.remove()


			chartGroup.selectAll(".goingline")
				//bind going data
				.data(goingData)
				.enter().append("path")
				.attr("class", "goingline")

				.attr("d", function (d, i) {
					// console.log(coming[i][selname], coming[i].state);
			
					var abb = d.abbrev;

					console.log(abb);

					//net changes btw going and coming
					var finalval = comingData[i][selname] - goingData[i][selname];

					//select the district (destination, id has been assigned) 
	
					var theState = d3.select("#" + abb);
					console.log(theState.nodes());

					//validate and check the net changes
					if (!isNaN(finalval)) {
						console.log((theState.nodes()[0].__data__));

						/*
						selections are arrays of arrays of DOM elements. 
						The outer-most array is called a 'selection', 
						the inner array(s) are called 'groups' and those groups contain the DOM elements.

						In the normal version (https://d3js.org/d3.v4.js), the console.log return should be: 
						Selection {_groups: Array[1], _parents: Array[1]}

						!!!!!use nodes(): to get the inner array(s)!!!!!
						*/

						//coordinates of the path destination
						var destx = path.centroid(theState.nodes()[0].__data__)[0];
						var desty = path.centroid(theState.nodes()[0].__data__)[1];

						//if theres changes meanig movements btw home distric and dest district
						if (finalval > 0) {
							return "M" + destx + "," + desty + " Q" + (destx + homex) / 2 + " " + (desty + homey) / 1.5 + " " + homex + " " + homey;

						} else {
							return "M" + homex + "," + homey + " Q" + (destx + homex) / 2 + " " + (desty + homey) / 2.5 + " " + destx + " " + desty;
						}
					}
				})

				//the drawing annimation
				.call(transition)

				//determine the stroke width based on net changes
				.attr("stroke-width", function (d, i) {
					var finalval = comingData[i][selname] - goingData[i][selname];

					return lineSize(parseFloat(Math.abs(finalval)));
				})
				//stroke color
				.attr("stroke", function (d, i) {
					var finalval = comingData[i][selname] - goingData[i][selname];
					if (finalval >= 0) {
						//color for positive growth
						return "#65a89d";
					} else {
						return "#a96a46";
					}

				})
				.attr("fill", "none")
				.attr("opacity", 0.5)
				.attr("stroke-linecap", "round")
				.on("mouseenter", function (d) {
					return toolOver2(d, this);
				})
				.on("mousemove", function (d, i) {
					var m = d3.mouse(this);
					mx = m[0];
					my = m[1];
					return toolMove2(mx, my, selname, d.state, comingData[i][selname], goingData[i][selname]);
				})
				.on("mouseleave", function (d) {
					return toolOut2(d, this);
				});


		}

		//must append elements or bind data before a transition starts.
		//use the attrTween and transform to navigate along the path
		function transition(path) {
			path.transition()
				.duration(2000)
				.attrTween("stroke-dasharray", tweenDash);
		}

		function tweenDash() {
			var l = this.getTotalLength(),
				i = d3.interpolateString("0," + l, l + "," + l);
			return function (t) { return i(t); };
		}

		d3.select(self.frameElement).style("height", "700px");

	</script>





</body>

</html>